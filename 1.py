# -*- coding: utf-8 -*-
"""Untitled21.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wFXI4sC0LA3qGO_AwpCMncFTHFCumMe2
"""
import numpy as np
import pandas as pd
from scipy.optimize import curve_fit
import matplotlib.pyplot as plt
import math
from scipy.optimize import minimize
from sklearn.metrics import mean_squared_error

df=pd.read_csv("./../data/04_cricket_1999to2011.csv")
#print(df.shape)
data_innings1=df[(df['Innings'] == 1)]
#print(d.shape)
print(len(set(df['Match'].values.tolist())))

data= data_innings1[['Innings.Total.Runs','Total.Runs','Over','Total.Out', 'Match']]
data_list=data.values.tolist()
#print(len(data_list))
#print(data_list[10])

match=data_innings1['Match'].values.tolist()
#print(len(match))
matchset=list(set(match))
#print(len(matchset))

match_num_non50=[]
match_non50_data=[]
for i in matchset:
  v=data_innings1.loc[(data_innings1['Match'] == i)]
  v2=v['Innings.Total.Out'].values.tolist()
  in_run=(v['Innings.Total.Runs'].values.tolist())[0]
  if (len(v2) != 50) and (v2[0]!=10):
      match_num_non50.append(i)
      xd=[len(v2), v2[0], i, in_run]
      match_non50_data.append(xd)
#print(match_non50_data)
#print(match_num_non50)

match_50=list(set(matchset).difference(set(match_num_non50)))
#print(len(match_50))

list50=[]
for i in match_50:
    ith_match=data_innings1.loc[(data_innings1['Match'] == i)]
    ith_match_list=ith_match['Innings.Total.Runs'].values.tolist()
    list50.append(ith_match_list[0])
#print(list50)
#print(len(list50))

def min_least_mean_squared_error(values,args):
    squared_loss = []
    l0 = values[10]
    #loss for points with 50 overs 0 wickets
    for i in list50:
      predicted_run = values[9] * (1.0 - math.exp(-1*l0*50/values[9]))
      squared_loss.append(math.pow(predicted_run - i, 2))
    #loss for points where less than 50 overs played(say x), so points with x overs 0 wickets
    for j in match_non50_data:
      o =int(j[0])
      predicted_run = values[9] * (1.0 - math.exp(-1*l0*o/values[9]))
      squared_loss.append(math.pow(predicted_run - j[3], 2))
    #loss for all other points present in dataset
    for row in data_list:
        run = int(row[0])-int(row[1])
        wicket = 10 - int(row[3])
        #if all 50 overs were played, total overs=50
        if row[4] not in match_num_non50:
          over = 50 - int(row[2])
        else:
          #else total overs = number of overs played
          for j in match_non50_data:
            if row[4]==j[2]:
              over = j[0] - int(row[2])
        if run > 0:
                      predicted_run = values[wicket-1] * (1.0 - math.exp(-1*l0*over/values[wicket-1]))
                      squared_loss.append(math.pow(predicted_run - run, 2))
    return np.sum(squared_loss)

initial_data = [10.0, 30.0, 50.0, 80.0, 100.0, 140.0, 170.0, 200.0, 240.0, 280.0, 11]
optimized_data = minimize(min_least_mean_squared_error, initial_data,args=[],method='L-BFGS-B')
print (optimized_data)

print("\n\n\n\noptimized values for z[w] \n", optimized_data['x'][0:10])
print("\n\noptimized value for L0 \n", optimized_data['x'][10])
print("\n\noptimized sum of squared loss \n", optimized_data['fun'])

x_data=optimized_data['x']
x1 = np.arange(50, -1, -1)
totl_resources_possible= x_data[9] * (1-np.exp(( -x_data[10]*50)/x_data[9]))
for i in range (10):
  y_data = 100* (x_data[i] * (1 - np.exp((-x_data[10]*x1)/x_data[i])))/totl_resources_possible
  plt.plot(x1,y_data)
#plt.show
plt.savefig('plot.pdf')
